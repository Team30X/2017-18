#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  lift_limit,     sensorTouch)
#pragma config(Sensor, dgtl2,  goal_limit,     sensorTouch)
#pragma config(Sensor, I2C_1,  lift,           sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           left1,         tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           left2,         tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port4,           right1,        tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,           right2,        tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           lift1,         tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port7,           lift2,         tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port8,           goal1,         tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port9,           goal2,         tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port10,          claw,          tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(105)
//Set motor Aliases and mode durations

#include "Vex_Competition_Includes.c"

float lift_pos;

void pre_auton() {
}
//goat meat
//Sets all motors to given value
void set_motors(int value) {
	motor[left1]=value;
	motor[left2]=value;
 	motor[right1]=value;
	motor[right2]=value;
}

//Gives given value to all lift motors
void set_lift(int value) {
	motor[lift1]=value;
	motor[lift2]=value;
}

void set_goal(int value) {
	motor[goal1]=value;
	motor[goal2]=value;
}

//Sets claw to open or close
void move_claw(int dir) {
	motor[claw]=64*dir;
}

//Turns in given direction, 1 is right, -1 is left
void turn(int dir) {
	motor[left1]=dir*127;
	motor[left2]=dir*127;
 	motor[right1]=dir*127*-1;
	motor[right2]=dir*127*-1;
}

//Gives joysticks values to motors
void check_joysticks() {
	int r = abs(vexRT[Ch3Xmtr2]) > 10 ? vexRT[Ch3Xmtr2] : 0;
	int l = abs(vexRT[Ch2Xmtr2]) > 10 ? vexRT[Ch2Xmtr2] : 0;
	motor[left1]=r;
	motor[left2]=r;
 	motor[right1]=l;
	motor[right2]=l;
}

//Checks if given full power button is pressed and sets motors
int check_full(int but, int dir) {
	 //if pressed then but*127*dir gives full power in desired direction
	if (but==1) set_motors(but*127*dir);
	return but; //returns but so no need to store but in temp var
}

//CHecks for sharp turn button and does correct directions
int check_sharp(int but, int dir) {
	if (but==1) turn(dir);
	return but;
}

bool claw_pressed = false;

//Checks for claw button and moves it
void check_claw() {
	if (vexRT[Btn5U]==1) {
		move_claw(1);
	} else if (vexRT[Btn5D]==1) {
		move_claw(-1);
	} else {
		move_claw(0);
	}
}

const float lift_speed = 25;

//Checks lift buttons and sets to appropriate value
void check_lift() {
	if (vexRT[Btn6U]==1) lift_pos += lift_speed;
	else if (vexRT[Btn6D]==1) lift_pos -= lift_speed;
}

void check_goal() {
	if (vexRT[Btn8U]==1) set_goal(127);
	else if (vexRT[Btn8D]==1 && !SensorValue[goal_limit]) set_goal(-127);
	else set_goal(0);
}

float kp = 0.1;
float ki = 0.2;
float kd = 0.2;

int sum;
int last_e;
int e;
task lift_PID() {
	sum = 0;
	last_e = 0;

	while (1) {
		e = lift_pos - SensorValue[lift];

		float t = kp*e + ki*sum + kd*(e-last_e);
		set_lift(t);

		sum = sum/3 + e;
		last_e = e;

		check_lift();

		Sleep(30);
	}
}

task autonomous {

}

int last7u = 0;

//main function
task usercontrol () {
	//calibrate lift
	set_lift(-127);
	while (!SensorValue[lift_limit]) {}
	Sleep(200);
	set_lift(0);
	SensorValue[lift] = 0;
	lift_pos = 0;
	StartTask(lift_PID);

	//main loop
	while (true) {
		check_claw();
		check_goal();
		if (vexRT[Btn7U] != last7u && last7u) {
			lift_pos = 2000;
		}
		last7u = vexRT[Btn7U];
		//if full power buttons pressed, skip rest of the steps
		//move precedence is forward, backwards, left, right, joystick
			if (check_full(vexRT[Btn7UXmtr2], 1)==1) continue;
			if (check_full(vexRT[Btn7DXmtr2], -1)==1) continue;
			if (check_sharp(vexRT[Btn7RXmtr2], 1)==1) continue;
			if (check_sharp(vexRT[Btn7LXmtr2], -1)==1) continue;
			//if both not pressed set motor to joysticks
			check_joysticks();

	}
}
